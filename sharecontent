using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace Trusted.Utils
{
    /// <summary>
    /// 工具类
    /// </summary>
    public static class Utils
    {
        #region 校验身份证合法性
        /// <summary>
        /// 校验身份证号是否符合规范 参考网址：
        /// </summary>
        /// <param name="">身份证号</param>
        /// <returns></returns>
        public static bool CheckIdCard_text(string idNumber)
        {
            if (idNumber.Length == 18)
            {
                bool check = CheckIdCard_text18(idNumber);
                return check;
            }
            else if (idNumber.Length == 15)
            {
                bool check = CheckIdCard_text15(idNumber);
                return check;
            }
            else
            {
                return false;
            }
        }

        private static bool CheckIdCard_text18(string Id)
        {
            long n = 0;
            if (long.TryParse(Id.Remove(17), out n) == false || n < Math.Pow(10, 16) || long.TryParse(Id.Replace('x', '0').Replace('X', '0'), out n) == false)
            {
                return false;//数字验证  
            }
            string address = "11x22x35x44x53x12x23x36x45x54x13x31x37x46x61x14x32x41x50x62x15x33x42x51x63x21x34x43x52x64x65x71x81x82x91";
            if (address.IndexOf(Id.Remove(2)) == -1)
            {
                return false;//省份验证  
            }

            string birth = Id.Substring(6, 8).Insert(6, "-").Insert(4, "-");
            DateTime time = new DateTime();
            if (DateTime.TryParse(birth, out time) == false)
            {
                return false;//生日验证  
            }

            string[] arrVarifyCode = ("1,0,x,9,8,7,6,5,4,3,2").Split(',');
            string[] Wi = ("7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2").Split(',');
            char[] Ai = Id.Remove(17).ToCharArray();
            int sum = 0;
            for (int i = 0; i < 17; i++)
            {
                sum += int.Parse(Wi[i]) * int.Parse(Ai[i].ToString());
            }
            int y = -1;
            DivRem(sum, 11, out y);
            if (arrVarifyCode[y] != Id.Substring(17, 1).ToLower())
            {
                return false;//校验码验证  
            }
            return true;//符合GB11643-1999标准  
        }

        private static int DivRem(int a, int b, out int result)
        {
            result = a % b;
            return (a / b);
        }

        private static bool CheckIdCard_text15(string Id)
        {
            long n = 0;
            if (long.TryParse(Id, out n) == false || n < Math.Pow(10, 14))
            {
                return false;//数字验证  
            }
            string address = "11x22x35x44x53x12x23x36x45x54x13x31x37x46x61x14x32x41x50x62x15x33x42x51x63x21x34x43x52x64x65x71x81x82x91";
            if (address.IndexOf(Id.Remove(2)) == -1)
            {
                return false;//省份验证  
            }
            string birth = Id.Substring(6, 6).Insert(4, "-").Insert(2, "-");
            DateTime time = new DateTime();
            if (DateTime.TryParse(birth, out time) == false)
            {
                return false;//生日验证  
            }
            return true;//符合15位身份证标准  
        }
        #endregion

        # region 发送数据3DES加密
        /// <summary>
        /// 3DES加密
        /// </summary>
        /// <param name="data">加密内容</param>
        /// <returns></returns>
        public static string EncodeSendData(string par, string sckey)
        {
            var desstr = "";
            if (par.IsNullOrEmty())
                return desstr;
            var data = Encoding.UTF8.GetBytes(par);
            byte[] iv = System.Text.Encoding.UTF8.GetBytes("01234567"); //密钥
            byte[] key = System.Text.Encoding.UTF8.GetBytes(sckey.Substring(0, 24)); //取前24位，向量

            try
            {
                using (MemoryStream mStream = new MemoryStream())
                {
                    TripleDESCryptoServiceProvider tdsp = new TripleDESCryptoServiceProvider();
                    tdsp.Mode = CipherMode.CBC;
                    tdsp.Padding = PaddingMode.PKCS7;
                    using (CryptoStream cStream = new CryptoStream(mStream, tdsp.CreateEncryptor(key, iv), CryptoStreamMode.Write))
                    {
                        cStream.Write(data, 0, data.Length);
                        cStream.FlushFinalBlock();
                        byte[] ret = mStream.ToArray();
                        desstr = Convert.ToBase64String(ret);
                    }
                }

            }
            catch (Exception ex)
            {
                Log.Error(ex);
            }

            return desstr;
        }

        /// <summary>
        /// 3DES解密方法
        /// </summary>
        /// <param name="par">需解密base64字符串，sckey为解密Key</param>
        /// <param name="sckey"></param>
        /// <returns></returns>
        public static string DecodeSendData(string par, string sckey)
        {
            byte[] inputByteArray = Convert.FromBase64String(par);
            byte[] iv = System.Text.Encoding.UTF8.GetBytes("01234567"); //密钥
            byte[] key = System.Text.Encoding.UTF8.GetBytes(sckey.Substring(0, 24)); //取前24位，向量

            // Create a new MemoryStream using the passed
            // array of encrypted data.
            using (MemoryStream msDecrypt = new MemoryStream(inputByteArray))
            {

                // Create a CryptoStream using the MemoryStream
                TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider();
                tripleDESCryptoServiceProvider.Padding = PaddingMode.PKCS7;//补位
                tripleDESCryptoServiceProvider.Mode = CipherMode.CBC;
                CryptoStream csDecrypt = new CryptoStream(msDecrypt,
                    tripleDESCryptoServiceProvider.CreateDecryptor(key, iv),
                    CryptoStreamMode.Read);

                // Create buffer to hold the decrypted data.
                byte[] fromEncrypt = new byte[inputByteArray.Length];

                // Read the decrypted data out of the crypto stream
                // and place it into the temporary buffer.
                csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);

                //Convert the buffer into a string and return it.
                return Encoding.UTF8.GetString(fromEncrypt).TrimEnd('\0');
            }
        }
        #endregion

        /// <summary>
        /// 将json格式改为url传参格式
        /// </summary>
        /// <param name="jsonString"></param>
        /// <returns></returns>
        public static String JsonToUrlDecode(string jsonString)
        {
            jsonString = jsonString.Replace("\"", "");
            jsonString = jsonString.Replace(":", "=");
            jsonString = jsonString.Replace(",", "&");
            return jsonString.Insert(1, "&");
        }

        /// <summary>
        /// 操作系统关机
        /// </summary>
        public static void SystemPowerOff()
        {
            Process.Start("shutdown.exe", "-s -t 00");//use shutdown.exe to shutdown system
        }

        /// <summary>
        /// 操作系统重启
        /// </summary>
        public static void SystemRestart()
        {
            Process.Start("shutdown.exe", "-r -t 00");//use shutdown.exe to restart system
        }

        /// <summary>
        /// double 转为int的拓展方法
        /// </summary>
        /// <param name="num"></param>
        /// <returns></returns>
        public static int ToIn32(this double num)
        {
            return Convert.ToInt32(num);
        }

        public static int ToInt32(this float num)
        {
            return Convert.ToInt32(num);
        }

        /// <summary>
        /// string转为int的拓展方法
        /// </summary>
        /// <param name="num"></param>
        /// <returns></returns>
        public static int ToIn32(this string num)
        {
            return Convert.ToInt32(num);
        }

        /// <summary>
        /// string 转byte
        /// </summary>
        /// <param name="bytestr"></param>
        /// <returns></returns>
        public static byte ToByte(this string bytestr)
        {
            return Convert.ToByte(bytestr);
        }

        /// <summary>
        /// 判断字符串是否无字符
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static bool IsEmpty(this string str)
        {
            return string.Empty == str;
        }

        /// <summary>
        /// 关闭进程
        /// </summary>
        /// <param name="processName"></param>
        public static void KillProcess(string processName)
        {
            try
            {
                Process[] ps = Process.GetProcesses();
                foreach (Process item in ps)
                {
                    if (item.ProcessName.ToLower() == processName.ToLower())
                    {
                        item.Kill();
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex);
            }
        }

        /// <summary>
        /// 判断进程是否存在
        /// </summary>
        /// <param name="processName"></param>
        public static bool IsProcessExist(string processName)
        {
            Process[] ps = Process.GetProcesses();
            foreach (Process item in ps)
            {
                if (item.ProcessName == processName)
                {
                    return true;
                }
            }

            return false;
        }

        public static int ProcessCount(string processName)
        {
            var count = 0;
            Process[] ps = Process.GetProcesses();
            foreach (Process item in ps)
            {
                if (item.ProcessName == processName)
                {
                    count++;
                }
            }

            return count;
        }

        public static bool IsNullOrEmty(this string str)
        {
            return string.IsNullOrEmpty(str);
        }

        public static string Base64Convert(string base64)
        {
            byte[] buffer = Convert.FromBase64String(base64);
            string Base64StrData = Convert.ToBase64String(buffer).Replace("+", "%2B");//注意加号（’+‘）的替换处理，否则由于加号经过Url传递后变成空格而得不到合法的Base64字符串
            return Base64StrData;
        }

        //验证电话号码的主要代码如下：
        public static bool IsTelephone(string str_telephone)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(str_telephone, @"^(\d{3,4}-)?\d{6,8}$");
        }
        //验证手机号码的主要代码如下：
        public static bool IsHandset(string str_handset)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(str_handset, @"^[1][3,4,5,7,8,9][0-9]{9}$");
        }
        //  验证身份证号的主要代码如下：
        public static bool IsIDcard(string str_idcard)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(str_idcard, @"(^\d{18}$)|(^\d{15}$)");
        }
        //验证输入为数字的主要代码如下：
        public static bool IsNumber(string str_number)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(str_number, @"^[0-9]*$");
        }
        //验证邮编的主要代码如下：
        public static bool IsPostalcode(string str_postalcode)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(str_postalcode, @"^\d{6}$");
        }

        /// <summary>
        /// 判断是否为中文
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static bool IsChinese(string str)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(str, @"[\u4e00-\u9fbb]");
        }

        /// <summary>
        /// 20180101日期格式
        /// </summary>
        /// <param name="datestr"></param>
        /// <returns></returns>
        public static bool IsDate(string datestr)
        {
            return datestr.Length == 8 && System.Text.RegularExpressions.Regex.IsMatch(datestr, "(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})(((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)(0[1-9]|[12][0-9]|30))|(02(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))0229)");
        }

        public static void CMD(string str)
        {

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo.FileName = "cmd.exe";
            p.StartInfo.UseShellExecute = false;    //是否使用操作系统shell启动
            p.StartInfo.RedirectStandardInput = true;//接受来自调用程序的输入信息
            p.StartInfo.RedirectStandardOutput = true;//由调用程序获取输出信息
            p.StartInfo.RedirectStandardError = true;//重定向标准错误输出
            p.StartInfo.CreateNoWindow = false;//不显示程序窗口
            p.Start();//启动程序

            //向cmd窗口发送输入信息
            p.StandardInput.WriteLine(str + "&exit\r\n");

            p.StandardInput.AutoFlush = true;
            //p.StandardInput.WriteLine("exit");
            //向标准输入写入要执行的命令。这里使用&是批处理命令的符号，表示前面一个命令不管是否执行成功都执行后面(exit)命令，如果不执行exit命令，后面调用ReadToEnd()方法会假死
            //同类的符号还有&&和||前者表示必须前一个命令执行成功才会执行后面的命令，后者表示必须前一个命令执行失败才会执行后面的命令



            //获取cmd窗口的输出信息
            string output = p.StandardOutput.ReadToEnd();

            //StreamReader reader = p.StandardOutput;
            //string line=reader.ReadLine();
            //while (!reader.EndOfStream)
            //{
            //    str += line + "  ";
            //    line = reader.ReadLine();
            //}

            p.WaitForExit();//等待程序执行完退出进程
            p.Close();

            Log.Debug(output);
        }

        /// <summary>
        /// 设置对象属性
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="PropertyName"></param>
        /// <param name="value"></param>
        public static void SetObjvalue(object obj, string PropertyName, object value)
        {
            if (obj != null)
            {
                var property = obj.GetType().GetProperty(PropertyName);//此时可以使用GetProperty获取属性数组，循环进行赋值，这里主要讲解类型问题。
                property.SetValue(obj, value, null);
            }
        }


        /// <summary> 
        /// 将c# DateTime时间格式转换为Unix时间戳格式  ms单位
        /// </summary> 
        /// <param name="time">时间</param> 
        /// <returns>long</returns> 
        public static long ConvertDateTimeToInt(System.DateTime time)
        {
            System.DateTime startTime = TimeZone.CurrentTimeZone.ToLocalTime(new System.DateTime(1970, 1, 1, 0, 0, 0, 0));
            long t = (time.Ticks - startTime.Ticks) / 10000;   //除10000调整为13位     
            return t;
        }
        /// <summary>       
        /// 时间戳转为C#格式时间    timeStamp=146471041000   ms为单位
        /// </summary>       
        /// <param name=”timeStamp”></param>       
        /// <returns></returns>       
        public static DateTime ConvertStringToDateTime(string timeStamp)
        {
            DateTime dtStart = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1));
            long lTime = long.Parse(timeStamp + "0000");
            TimeSpan toNow = new TimeSpan(lTime);
            return dtStart.Add(toNow);
        }
    }
}
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Trusted.Utils
{
    /// <summary>
    /// Log4Net帮助类
    /// </summary>
    public class Log
    {
        public static readonly log4net.ILog Logdebug = log4net.LogManager.GetLogger("logdebug");
        public static readonly log4net.ILog Loginfo = log4net.LogManager.GetLogger("loginfo");
        public static readonly log4net.ILog Logwarn = log4net.LogManager.GetLogger("logwarn");
        public static readonly log4net.ILog Logerror = log4net.LogManager.GetLogger("logerror");
        public static readonly log4net.ILog Logfatal = log4net.LogManager.GetLogger("logfatal");
        public static readonly log4net.ILog LogOracle = log4net.LogManager.GetLogger("WarningDatail_Oracle");

        public Log()
        {
            log4net.Config.XmlConfigurator.Configure();
        }

        public static void SetConfig()
        {
            log4net.Config.XmlConfigurator.Configure();
        }

        public static void SetConfig(FileInfo configFile)
        {
            log4net.Config.XmlConfigurator.Configure(configFile);
        }

        public static void Info(string info)
        {

            Loginfo.Info(info);

        }

        /// <summary>
        /// DEBUG （调试信息）：记录系统用于调试的一切信息，内容或者是一些关键数据内容的输出。
        /// </summary>
        /// <param name="info"></param>
        public static void Debug(string info)
        {

            Logdebug.Debug(info);

        }

        /// <summary>
        /// WARN（警告）：记录系统中不影响系统继续运行，但不符合系统运行正常条件，有可能引起系统错误的信息。例如，记录内容为空，数据内容不正确等。
        /// </summary>
        /// <param name="info"></param>
        public static void Warn(string info)
        {
            if (Logwarn.IsWarnEnabled)
            {
                Logwarn.Warn(info);
            }
        }

        /// <summary>
        /// ERROR（一般错误）：记录系统中出现的导致系统不稳定，部分功能出现混乱或部分功能失效一类的错误。例如，数据字段为空，数据操作不可完成，操作出现异常等。
        /// </summary>
        /// <param name="info"></param>
        /// <param name="se"></param>
        public static void Error(string info, Exception se)
        {

            Logerror.Error(info, se);

        }

        /// <summary>
        /// 错误记录
        /// </summary>
        /// <param name="info"></param>
        public static void Error(string info)
        {
            if (Logerror.IsErrorEnabled)
            {
                Logerror.Error(info);
            }
        }

        public static void Error(Exception info)
        {
            if (Logerror.IsErrorEnabled)
            {
                Logerror.Error(info);
            }
        }

        /// <summary>
        /// FATAL（致命错误）：记录系统中出现的能使用系统完全失去功能，服务停止，系统崩溃等使系统无法继续运行下去的错误。例如，数据库无法连接，系统出现死循环。
        /// </summary>
        /// <param name="info"></param>
        /// <param name="se"></param>
        public static void Fatal(string info, Exception se)
        {
            if (Logfatal.IsFatalEnabled)
            {
                Logfatal.Fatal(info, se);
            }
        }
    }
}
